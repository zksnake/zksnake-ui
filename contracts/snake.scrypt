import "verifier.scrypt";

contract Snake {

    PubKey you;
    PubKey computer;

    int yourHash;
    int computerHash;

    @state
    int successfulYourHits;

    @state
    int successfulComputerHits;

    @state
    bool yourTurn;


    @state
    bool[100] yourHits;

    @state
    bool[100] computerHits;

    public function move(Sig sig, int x, int y, bool hit, Proof proof, int amount, SigHashPreimage txPreimage)
    {
        require(Tx.checkPreimage(txPreimage));

        require(ZKSNARK.verify([this.yourTurn ? this.computerHash : this.yourHash, x, y, hit ? 1 : 0], proof));


        PubKey pubKey = this.yourTurn ? this.you : this.computer;
        require(checkSig(sig, pubKey));


        if (this.yourTurn) {
            require(!this.yourHits[coordsToIndex(x,y)]);
            this.yourHits[coordsToIndex(x,y)] = true;
            if (hit) {
                this.successfulYourHits++;
            }
        }
        else {
            require(!this.computerHits[coordsToIndex(x,y)]);
            this.computerHits[coordsToIndex(x,y)] = true;
            if (hit) {
                this.successfulComputerHits++;
            }
        }

        this.yourTurn = !this.yourTurn;

        bytes outputs = b'';

        if (this.successfulYourHits == 2) {
            bytes script = Utils.buildPublicKeyHashScript(hash160(this.you));
            outputs = Utils.buildOutput(script, amount);
        }
        else if (this.successfulComputerHits == 2) {
            bytes script = Utils.buildPublicKeyHashScript(hash160(this.computer));
            outputs = Utils.buildOutput(script, amount);
        }
        else {

            bytes outputScript = this.getStateScript();
            outputs = Utils.buildOutput(outputScript, amount);
        }

        // make sure the transaction contains the expected outputs
        require(hash256(outputs) == SigHash.hashOutputs(txPreimage));
    }

    static function coordsToIndex(int x, int y) : int {
        return y * 10 + x;
    }
}
